#!/usr/bin/env python3
"""
AST Code Manipulator - Method Stubber

This script demonstrates how to:
1. Parse source code into AST
2. Manipulate the AST (stub methods)
3. Generate modified source code back

It creates stubbed versions of Java and Kotlin classes.
"""

from tree_sitter import Language, Parser
import os
import re

class JavaCodeStubber:
    def __init__(self, java_language):
        self.java_language = java_language
        self.parser = Parser()
        self.parser.set_language(java_language)
    
    def stub_java_methods(self, source_code):
        """
        Parse Java code and return a stubbed version
        """
        tree = self.parser.parse(source_code.encode())
        
        # We'll build the new code by replacing method bodies
        modified_code = source_code
        
        # Find all methods and collect their body locations (in reverse order to maintain positions)
        methods_to_stub = []
        self._find_methods_recursive(tree.root_node, source_code, methods_to_stub)
        
        # Debug: Print method information
        print(f"Found {len(methods_to_stub)} methods to stub:")
        for i, method in enumerate(methods_to_stub):
            print(f"  {i+1}. {method['name']}() -> {method['return_type']} (body: {method['body_start']}-{method['body_end']})")
        
        # Sort by start position in reverse order so we can replace from end to beginning
        methods_to_stub.sort(key=lambda x: x['body_start'], reverse=True)
        
        # Replace each method body with a stub
        for method in methods_to_stub:
            if method['body_start'] is not None and method['body_end'] is not None:
                # Generate stub body
                stub_body = self._generate_java_stub_body(method)
                
                # Replace the method body in the source code
                before = modified_code[:method['body_start']]
                after = modified_code[method['body_end']:]
                modified_code = before + stub_body + after
        
        return modified_code
    
    def _find_methods_recursive(self, node, source_code, methods_list):
        """Recursively find all method declarations"""
        if node.type == 'method_declaration':
            method_info = self._extract_method_info(node, source_code)
            if method_info:
                methods_list.append(method_info)
        
        for child in node.children:
            self._find_methods_recursive(child, source_code, methods_list)
    
    def _extract_method_info(self, method_node, source_code):
        """Extract method information from a method_declaration node"""
        method_info = {
            'name': 'unknown',
            'return_type': 'void',
            'parameters': [],
            'modifiers': [],
            'body_start': None,
            'body_end': None
        }
        
        # Track if we've found a return type yet
        found_return_type = False
        
        for child in method_node.children:
            if child.type == 'modifiers':
                for mod_child in child.children:
                    if mod_child.type in ['public', 'private', 'protected', 'static', 'final', 'abstract']:
                        method_info['modifiers'].append(source_code[mod_child.start_byte:mod_child.end_byte])
            
            elif child.type in ['integral_type', 'floating_point_type', 'boolean_type']:
                method_info['return_type'] = source_code[child.start_byte:child.end_byte]
                found_return_type = True
            elif child.type == 'type_identifier':
                method_info['return_type'] = source_code[child.start_byte:child.end_byte]
                found_return_type = True
            elif child.type == 'void_type':
                method_info['return_type'] = 'void'
                found_return_type = True
            elif child.type == 'generic_type':
                method_info['return_type'] = source_code[child.start_byte:child.end_byte]
                found_return_type = True
            elif child.type == 'array_type':  # Added array type detection
                method_info['return_type'] = source_code[child.start_byte:child.end_byte]
                found_return_type = True
            elif child.type == 'scoped_type_identifier':  # For types like MediaBrowserCompat.MediaItem
                method_info['return_type'] = source_code[child.start_byte:child.end_byte]
                found_return_type = True
            
            elif child.type == 'identifier':
                # Only set as method name if we haven't found a return type yet
                # (to avoid confusing return type identifiers with method names)
                if found_return_type:
                    method_info['name'] = source_code[child.start_byte:child.end_byte]
                else:
                    # This might be a return type identifier we missed
                    method_info['return_type'] = source_code[child.start_byte:child.end_byte]
            
            elif child.type == 'formal_parameters':
                method_info['parameters'] = self._extract_parameters(child, source_code)
            
            elif child.type == 'block':
                method_info['body_start'] = child.start_byte
                method_info['body_end'] = child.end_byte
        
        # Fallback: if we still haven't found the method name, scan again more carefully
        if method_info['name'] == 'unknown':
            method_info['name'] = self._extract_method_name_fallback(method_node, source_code)
        
        return method_info
    
    def _extract_method_name_fallback(self, method_node, source_code):
        """Fallback method to extract method name when primary extraction fails"""
        # Look for identifier nodes that come after the return type
        identifiers = []
        
        def find_identifiers(node):
            if node.type == 'identifier':
                identifiers.append(source_code[node.start_byte:node.end_byte])
            for child in node.children:
                find_identifiers(child)
        
        find_identifiers(method_node)
        
        # The method name is typically the last identifier before parameters
        # or the first identifier that's not a known type
        known_types = ['public', 'private', 'protected', 'static', 'final', 'abstract', 
                      'int', 'long', 'boolean', 'String', 'void', 'MediaBrowserCompat', 'MediaItem']
        
        for identifier in reversed(identifiers):
            if identifier not in known_types:
                return identifier
        
        return 'unknown'
    
    def _extract_parameters(self, params_node, source_code):
        """Extract parameter information"""
        parameters = []
        
        for child in params_node.children:
            if child.type == 'formal_parameter':
                param_type = ''
                param_name = ''
                
                for p_child in child.children:
                    if p_child.type in ['integral_type', 'floating_point_type', 'boolean_type', 'type_identifier']:
                        param_type = source_code[p_child.start_byte:p_child.end_byte]
                    elif p_child.type == 'generic_type':
                        param_type = source_code[p_child.start_byte:p_child.end_byte]
                    elif p_child.type == 'array_type':
                        param_type = source_code[p_child.start_byte:p_child.end_byte]
                    elif p_child.type == 'identifier':
                        param_name = source_code[p_child.start_byte:p_child.end_byte]
                
                if param_type and param_name:
                    parameters.append({'type': param_type, 'name': param_name})
        
        return parameters
    
    def _is_array_type(self, type_str):
        """Check if a type string represents an array"""
        return type_str.endswith('[]') or '[]' in type_str
    
    def _get_array_component_type(self, array_type):
        """Extract the component type from an array type"""
        # Remove [] from the end and any whitespace
        component_type = array_type.replace('[]', '').strip()
        return component_type
    
    def _generate_array_creation(self, array_type, method_name):
        """Generate appropriate array creation code"""
        component_type = self._get_array_component_type(array_type)
        
        # Special case for newArray methods - they should create arrays of specified size
        if method_name == 'newArray':
            return f"return new {component_type}[size];"
        
        # For other array methods, return empty array
        return f"return new {component_type}[0];"
    
    def _generate_java_stub_body(self, method_info):
        """Generate appropriate stub body for Java method"""
        return_type = method_info['return_type'].strip()
        method_name = method_info['name']
        
        # Debug output
        print(f"Generating stub for {method_name}() with return type '{return_type}'")
        
        # Create indented stub body
        stub_lines = []
        stub_lines.append(" {")
        stub_lines.append(f"        // TODO: Implement {method_name}")
        
        # Add appropriate return statement
        if return_type == 'void':
            stub_lines.append("        // Method implementation goes here")
        elif return_type in ['int', 'long', 'short', 'byte']:
            stub_lines.append("        return 0;")
        elif return_type == 'float':
            stub_lines.append("        return 0.0f;")  # Float literal needs 'f' suffix
        elif return_type == 'double':
            stub_lines.append("        return 0.0;")
        elif return_type == 'boolean':
            stub_lines.append("        return false;")
        elif return_type == 'char':
            stub_lines.append("        return '\\0';")
        elif return_type == 'String':
            stub_lines.append("        return \"\";")
        elif self._is_array_type(return_type):
            # Handle array types properly
            array_creation = self._generate_array_creation(return_type, method_name)
            stub_lines.append(f"        {array_creation}")
        else:
            # For all other reference types (including generic types, complex types, unknown types)
            # Always add a return null to be safe
            stub_lines.append("        return null;")
        
        stub_lines.append("    }")
        
        return '\n'.join(stub_lines)

class KotlinCodeStubber:
    def __init__(self, kotlin_language):
        self.kotlin_language = kotlin_language
        self.parser = Parser()
        self.parser.set_language(kotlin_language)
    
    def stub_kotlin_functions(self, source_code):
        """
        Parse Kotlin code and return a stubbed version
        """
        tree = self.parser.parse(source_code.encode())
        
        # We'll build the new code by replacing function bodies
        modified_code = source_code
        
        # Find all functions and collect their body locations
        functions_to_stub = []
        self._find_functions_recursive(tree.root_node, source_code, functions_to_stub)
        
        # Filter out functions without bodies (interfaces, abstract methods)
        functions_to_stub = [f for f in functions_to_stub if f['body_start'] is not None and f['body_end'] is not None]
        
        # Sort by start position in reverse order
        functions_to_stub.sort(key=lambda x: x['body_start'], reverse=True)
        
        # Replace each function body with a stub
        for function in functions_to_stub:
            # Generate stub body
            stub_body = self._generate_kotlin_stub_body(function)
            
            # Replace the function body in the source code
            before = modified_code[:function['body_start']]
            after = modified_code[function['body_end']:]
            modified_code = before + stub_body + after
        
        return modified_code
    
    def _find_functions_recursive(self, node, source_code, functions_list):
        """Recursively find all function declarations"""
        if node.type == 'function_declaration':
            function_info = self._extract_function_info(node, source_code)
            # CRITICAL: Skip constructors - they should never be stubbed
            # Constructors are part of class declarations and stubbing them breaks the class structure
            if function_info and function_info.get('name') != 'constructor':
                functions_list.append(function_info)
        
        for child in node.children:
            self._find_functions_recursive(child, source_code, functions_list)
    
    def _extract_function_info(self, func_node, source_code):
        """Extract function information from a function_declaration node"""
        func_info = {
            'name': 'unknown',
            'return_type': 'Unit',
            'parameters': [],
            'modifiers': [],
            'body_start': None,
            'body_end': None,
            'is_suspend': False
        }
        
        # Track if we've seen the function name yet (return type comes after it)
        has_seen_name = False
        
        for child in func_node.children:
            if child.type == 'modifiers':
                for mod_child in child.children:
                    modifier = source_code[mod_child.start_byte:mod_child.end_byte]
                    func_info['modifiers'].append(modifier)
                    if modifier == 'suspend':
                        func_info['is_suspend'] = True
            
            elif child.type == 'simple_identifier':
                func_info['name'] = source_code[child.start_byte:child.end_byte]
                has_seen_name = True
            
            elif child.type == 'function_value_parameters':
                func_info['parameters'] = self._extract_kotlin_parameters(child, source_code)
            
            # FIXED: Better return type extraction - capture the full type expression
            elif has_seen_name and child.type in ['user_type', 'type_identifier', 'nullable_type', 'type_projection']:
                # Extract the complete type, including generics and nullable markers
                func_info['return_type'] = source_code[child.start_byte:child.end_byte].strip()
            
            elif child.type == 'function_body':
                # Tree-sitter's function_body node may not correctly handle nested lambdas
                # Store the start, but we'll find the true end by counting braces
                func_info['body_start_hint'] = child.start_byte
                func_info['body_end_hint'] = child.end_byte
        
        # FIXED: Manually find true function body boundaries by counting braces
        # This handles complex Kotlin code with nested lambdas that confuse tree-sitter
        if func_info.get('body_start_hint') is not None:
            func_info['body_start'], func_info['body_end'] = self._find_true_function_body(
                source_code, func_info['body_start_hint']
            )
        
        return func_info
    
    def _find_true_function_body(self, source_code: str, start_hint: int):
        """
        Find the true function body by counting braces from the opening brace.
        This is more reliable than tree-sitter's function_body node for complex Kotlin code.
        
        CRITICAL: We need to find the FIRST opening brace at or after the hint position,
        then count braces from there. Tree-sitter might point to an inner brace.
        """
        # Move backwards from hint to find the function signature line
        # Look for the pattern: ") {" or ") :" which marks the start of function body
        pos = start_hint
        
        # First, move back to find the closing paren of parameters
        paren_count = 0
        while pos > 0:
            if source_code[pos] == ')':
                paren_count += 1
                if paren_count == 1:
                    # Found the closing paren of parameters
                    break
            pos -= 1
        
        # Now move forward from this paren to find the opening brace
        # Pattern could be: ")" or ": ReturnType" followed by "{"
        while pos < len(source_code):
            if source_code[pos] == '{':
                # Found the function's opening brace
                break
            pos += 1
        
        if pos >= len(source_code):
            return None, None
        
        # Now count braces to find the matching closing brace
        brace_count = 0
        in_string = False
        in_char = False
        in_comment = False
        in_multiline_comment = False
        escape_next = False
        
        start_pos = pos
        
        while pos < len(source_code):
            char = source_code[pos]
            
            # Handle escape sequences
            if escape_next:
                escape_next = False
                pos += 1
                continue
            
            if char == '\\' and (in_string or in_char):
                escape_next = True
                pos += 1
                continue
            
            # Handle comments
            if not in_string and not in_char:
                if pos + 1 < len(source_code):
                    two_char = source_code[pos:pos+2]
                    if two_char == '/*':
                        in_multiline_comment = True
                        pos += 2
                        continue
                    elif two_char == '//':
                        in_comment = True
                        pos += 2
                        continue
                    elif two_char == '*/' and in_multiline_comment:
                        in_multiline_comment = False
                        pos += 2
                        continue
            
            if in_comment:
                if char == '\n':
                    in_comment = False
                pos += 1
                continue
            
            if in_multiline_comment:
                pos += 1
                continue
            
            # Handle strings
            if char == '"' and not in_char:
                in_string = not in_string
            elif char == '\'' and not in_string:
                in_char = not in_char
            
            # Count braces when not in string/char/comment
            if not in_string and not in_char and not in_comment and not in_multiline_comment:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        # Found the matching closing brace
                        return (start_pos, pos + 1)
            
            pos += 1
        
        # Couldn't find matching brace
        return None, None
    
    def _extract_kotlin_parameters(self, params_node, source_code):
        """Extract Kotlin parameter information"""
        parameters = []
        
        for child in params_node.children:
            if child.type == 'parameter':
                param_name = ''
                param_type = ''
                
                for p_child in child.children:
                    if p_child.type == 'simple_identifier':
                        param_name = source_code[p_child.start_byte:p_child.end_byte]
                    elif p_child.type in ['user_type', 'type_identifier']:
                        param_type = source_code[p_child.start_byte:p_child.end_byte]
                
                if param_name:
                    parameters.append({'name': param_name, 'type': param_type or 'Any'})
        
        return parameters
    
    def _is_array_type_kotlin(self, type_str):
        """Check if a Kotlin type string represents an array"""
        return type_str.startswith('Array<') or type_str.endswith('Array')
    
    def _generate_kotlin_stub_body(self, func_info):
        """Generate appropriate stub body for Kotlin function - WITHOUT braces (tree-sitter includes them)"""
        return_type = func_info['return_type']
        func_name = func_info['name']
        is_suspend = func_info['is_suspend']
        
        # Create indented stub body WITHOUT opening/closing braces
        # Tree-sitter's function_body node already includes the braces
        stub_lines = []
        stub_lines.append(" {")  # Opening brace
        stub_lines.append(f"        // TODO: Implement {func_name}")
        
        # FIXED: Better nullable type detection - handle complex types like List<String?>?, Flow<Data>?
        is_nullable = '?' in return_type and return_type.rstrip().endswith('?')
        # Remove trailing ? and whitespace to get base type
        base_type = return_type.rstrip().rstrip('?').strip()
        
        # Extract the core type without generics for primitive checks
        core_type = base_type.split('<')[0].split('.')[- 1].strip()
        
        # Add appropriate return statement
        if return_type == 'Unit' or return_type == '' or core_type == 'Unit':
            # Unit functions don't need return
            stub_lines.append("        // Function implementation goes here")
        elif core_type in ['Int', 'Long', 'Short', 'Byte']:
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return 0")
        elif core_type in ['Float', 'Double']:
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return 0.0")
        elif core_type == 'Boolean':
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return false")
        elif core_type == 'String':
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return \"\"")
        elif core_type in ['List', 'MutableList', 'ArrayList']:
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return emptyList()")
        elif core_type in ['Set', 'MutableSet', 'HashSet']:
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return emptySet()")
        elif core_type in ['Map', 'MutableMap', 'HashMap']:
            if is_nullable:
                stub_lines.append("        return null")
            else:
                stub_lines.append("        return emptyMap()")
        elif self._is_array_type_kotlin(base_type):
            # Handle Kotlin arrays
            if is_nullable:
                stub_lines.append("        return null")
            elif func_name == 'newArray':
                stub_lines.append("        return arrayOfNulls(size)")
            else:
                stub_lines.append("        return emptyArray()")
        elif is_nullable:
            # Nullable types - return null (safe default)
            stub_lines.append("        return null")
        else:
            # Non-nullable reference types - use error() which compiles correctly
            # This throws IllegalStateException at runtime, which is acceptable for stubs
            stub_lines.append(f"        error(\"Not yet implemented: {func_name}\")")
        
        stub_lines.append("    }")  # Closing brace
        
        return '\n'.join(stub_lines)