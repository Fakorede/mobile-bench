{"instance_id": "AntennaPod__AntennaPod-7215", "model_name": "Gemini 2.5 Flash", "model_name_or_path": "google/gemini-2.5-flash", "generated_patch": "--- a/parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java\n+++ b/parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java\n@@ -33,7 +33,7 @@\n             findOggPage();\n             findCommentHeader();\n             VorbisCommentHeader commentHeader = readCommentHeader();\n-            Log.d(TAG, commentHeader.toString());\n+            Log.d(TAG, \"VorbisCommentHeader \" + commentHeader.toString());\n             for (int i = 0; i < commentHeader.getUserCommentLength(); i++) {\n                 readUserComment();\n             }\n@@ -67,7 +67,7 @@\n             }\n             String key = readContentVectorKey(vectorLength).toLowerCase(Locale.US);\n             boolean shouldReadValue = handles(key);\n-            Log.d(TAG, \"key=\" + key + \", length=\" + vectorLength + \", handles=\" + shouldReadValue);\n+            Log.d(TAG, \"key=\" + key + \", length=\" + vectorLength + \", handles=\" + shouldReadValue + \", valueLength=\" + (vectorLength - key.length() - 1));\n             if (shouldReadValue) {\n                 String value = readUtf8String(vectorLength - key.length() - 1);\n                 onContentVectorValue(key, value);", "full_output": "```diff\n--- a/parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java\n+++ b/parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java\n@@ -33,7 +33,7 @@\n             findOggPage();\n             findCommentHeader();\n             VorbisCommentHeader commentHeader = readCommentHeader();\n-            Log.d(TAG, commentHeader.toString());\n+            Log.d(TAG, \"VorbisCommentHeader \" + commentHeader.toString());\n             for (int i = 0; i < commentHeader.getUserCommentLength(); i++) {\n                 readUserComment();\n             }\n@@ -67,7 +67,7 @@\n             }\n             String key = readContentVectorKey(vectorLength).toLowerCase(Locale.US);\n             boolean shouldReadValue = handles(key);\n-            Log.d(TAG, \"key=\" + key + \", length=\" + vectorLength + \", handles=\" + shouldReadValue);\n+            Log.d(TAG, \"key=\" + key + \", length=\" + vectorLength + \", handles=\" + shouldReadValue + \", valueLength=\" + (vectorLength - key.length() - 1));\n             if (shouldReadValue) {\n                 String value = readUtf8String(vectorLength - key.length() - 1);\n                 onContentVectorValue(key, value);\n```", "prompt_tokens": 5094, "completion_tokens": 347, "total_tokens": 5441, "response_time": 1.0832691192626953, "cost": 0.0023957, "base_commit": "e2ff09bd344e4c53ef40381f533fe26914604492", "error": null, "timestamp": "2025-07-07T18:31:22.069506", "prompt": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nFailed to parse vorbis comment spanning pages\n### Checklist\n\n- [X] I have used the search function for [**OPEN**](https://github.com/AntennaPod/AntennaPod/issues) issues to see if someone else has already submitted the same bug report.\n- [X] I have **also** used the search function for [**CLOSED**](https://github.com/AntennaPod/AntennaPod/issues?q=is%3Aissue+is%3Aclosed) issues to see if the problem is already solved and just waiting to be released.\n- [X] I will describe the problem with as much detail as possible.\n- [X] If the bug only to occurs with a certain podcast, I will include the URL of that podcast.\n\n### App version\n\n3.3.2\n\n### Where did you get the app from\n\nGoogle Play\n\n### Android version\n\n14\n\n### Device model\n\n_No response_\n\n### First occurred\n\n_No response_\n\n### Steps to reproduce\n\n1. Prepare a mp3 file with embedded cover and `comment` ID3 tag\r\n2. Convert to opus: `ffmpeg -i file.mp3 -f flac - | opusenc - file.opus`\r\n3. Confirm `comment` tag exists in converted file\r\n```sh\r\nâžœ opusinfo file.opus\r\nProcessing file \"file.opus\"...\r\n\r\nNew logical stream (#1, serial: 4d363549): type opus\r\nEncoded with libopus 1.5.1, libopusenc 0.2.1\r\nUser comments section follows...\r\n\tENCODER=opusenc from opus-tools 0.2\r\n\tMETADATA_BLOCK_PICTURE=3|image/png||880x880x32|<346606 bytes of image data>\r\n\tcomment=Summary\r\n```\r\n4. Put file.opus into local folder\r\n5. Refresh\n\n### Expected behaviour\n\nComment \"Summary\" displayed in shownotes.\n\n### Current behaviour\n\nShownotes not showing up. And log reports `User comment unrealistically long. key=jKd2/zT71n, length=2004374095`.\r\n\r\nAfter digging into code and file content, I guess that's because  `VorbisCommentReader` expect that all comments fit within a single page. But the embedded cover `METADATA_BLOCK_PICTURE` was too big so it's divided into n pages. In result, `readUserComment()` failed to skip whole `METADATA_BLOCK_PICTURE` segment. Thus next time, `readUserComment()` will read from somewhere within `METADATA_BLOCK_PICTURE` rather than beginning of next field.\n\n### Logs\n\n```\r\n04-06 19:51:50.236 17733 21131 D LocalFeedUpdater: Unable to parse ID3 of content://com.android.externalstorage.documents/tree/primary%3AMusic%2F%E6%82%84%E6%82%84%E8%AF%9D/document/primary%3AMusic%2F%E6%82%84%E6%82%84%E8%AF%9D%2Ffile.opus: Expected I and got O\r\n04-06 19:51:50.240 17733 21131 D VorbisCommentReader: VorbisCommentHeader [vendorString=libopus 1.5.1, libopusenc 0.2.1, userCommentLength=3]\r\n04-06 19:51:50.240 17733 21131 D VorbisCommentReader: key=encoder, length=35, handles=false\r\n04-06 19:51:50.240 17733 21131 D VorbisCommentReader: key=metadata_block_picture, length=462219, handles=false\r\n04-06 19:51:50.240 17733 21131 D LocalFeedUpdater: Unable to parse vorbis comments of content://com.android.externalstorage.documents/tree/primary%3AMusic%2F%E6%82%84%E6%82%84%E8%AF%9D/document/primary%3AMusic%2F%E6%82%84%E6%82%84%E8%AF%9D%2Ffile.opus: User comment unrealistically long. key=jKd2/zT71n, length=2004374095\r\n```\n\n</issue>\n\n<code>\n[start of README.md]\n1 # AntennaPod\n2 \n3 This is the official repository of AntennaPod, the easy-to-use, flexible and open-source podcast manager for Android.\n4 \n5 [<img src=\"https://play.google.com/intl/en_us/badges/images/generic/en_badge_web_generic.png\"\n6       alt=\"Get it on Google Play\"\n7       height=\"70\">](https://play.google.com/store/apps/details?id=de.danoeh.antennapod)\n8 [<img src=\"https://fdroid.gitlab.io/artwork/badge/get-it-on.png\"\n9       alt=\"Get it on F-Droid\"\n10       height=\"70\">](https://f-droid.org/app/de.danoeh.antennapod)\n11 \n12 <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/00.png\" alt=\"Screenshot 0\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/01.png\" alt=\"Screenshot 1\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/02.png\" alt=\"Screenshot 2\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/03.png\" alt=\"Screenshot 3\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/04.png\" alt=\"Screenshot 4\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/05.png\" alt=\"Screenshot 5\" height=\"200\">\n13 \n14 \n15 ## Feedback\n16 You can use the [AntennaPod Forum](https://forum.antennapod.org/) for discussions about the app or just podcasting in general.\n17 \n18 Bug reports and feature requests can be submitted [here](https://github.com/AntennaPod/AntennaPod/issues) (please read the [instructions](https://github.com/AntennaPod/AntennaPod/blob/develop/CONTRIBUTING.md) on how to report a bug and how to submit a feature request first!).\n19 \n20 We also hold regular community calls to discuss anything AntennaPod-related. [Come join the next call](https://forum.antennapod.org/t/monthly-community-call/1869)!\n21 \n22 ## Help to test AntennaPod\n23 AntennaPod has many users and we don't want them to run into trouble when we add a new feature. It's important that we have a significant group test our app, so that we know all possible combinations of phones, Android versions and use cases work as expected. Check out our wiki on how to join our [Beta testing program](https://antennapod.org/documentation/general/beta)! If a bug is reported during the beta period, chances are high that it will be fixed before the stable version. If it is reported later, fixing might take another full beta cycle. So definitely let us know if something is not right.\n24 \n25 ## License\n26 \n27 AntennaPod is licensed under the GNU General Public License (GPL-3.0). You can find the license text in the LICENSE file.\n28 \n29 ## Translating AntennaPod\n30 \n31 If you want to translate AntennaPod into another language, you can visit the [Transifex project page](https://www.transifex.com/antennapod/antennapod/).\n32 \n33 \n34 ## Building AntennaPod\n35 \n36 You can build AntennaPod just like any other Android project. Refer to the [instructions](https://github.com/AntennaPod/AntennaPod/blob/develop/CONTRIBUTING.md) for more details.\n37 \n38 \n[end of README.md]\n[start of /dev/null]\n1 \n[end of /dev/null]\n[start of parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java]\n1 package de.danoeh.antennapod.parser.media.vorbis;\n2 \n3 import androidx.annotation.NonNull;\n4 import org.apache.commons.io.EndianUtils;\n5 import org.apache.commons.io.IOUtils;\n6 import android.util.Log;\n7 \n8 import java.io.IOException;\n9 import java.io.InputStream;\n10 import java.io.UnsupportedEncodingException;\n11 import java.nio.ByteBuffer;\n12 import java.nio.charset.Charset;\n13 import java.util.Locale;\n14 \n15 public abstract class VorbisCommentReader {\n16     private static final String TAG = \"VorbisCommentReader\";\n17     private static final int FIRST_OGG_PAGE_LENGTH = 58;\n18     private static final int FIRST_OPUS_PAGE_LENGTH = 47;\n19     private static final int SECOND_PAGE_MAX_LENGTH = 64 * 1024 * 1024;\n20     private static final int PACKET_TYPE_IDENTIFICATION = 1;\n21     private static final int PACKET_TYPE_COMMENT = 3;\n22 \n23     private final InputStream input;\n24 \n25     VorbisCommentReader(InputStream input) {\n26         this.input = input;\n27     }\n28 \n29     public void readInputStream() throws VorbisCommentReaderException {\n30         try {\n31             findIdentificationHeader();\n32             findOggPage();\n33             findCommentHeader();\n34             VorbisCommentHeader commentHeader = readCommentHeader();\n35             Log.d(TAG, commentHeader.toString());\n36             for (int i = 0; i < commentHeader.getUserCommentLength(); i++) {\n37                 readUserComment();\n38             }\n39         } catch (IOException e) {\n40             Log.d(TAG, \"Vorbis parser: \" + e.getMessage());\n41         }\n42     }\n43 \n44     private void findOggPage() throws IOException {\n45         // find OggS\n46         byte[] buffer = new byte[4];\n47         final byte[] oggPageHeader = {'O', 'g', 'g', 'S'};\n48         for (int bytesRead = 0; bytesRead < SECOND_PAGE_MAX_LENGTH; bytesRead++) {\n49             int data = input.read();\n50             if (data == -1) {\n51                 throw new IOException(\"EOF while trying to find vorbis page\");\n52             }\n53             buffer[bytesRead % buffer.length] = (byte) data;\n54             if (bufferMatches(buffer, oggPageHeader, bytesRead)) {\n55                 break;\n56             }\n57         }\n58         // read segments\n59         IOUtils.skipFully(input, 22);\n60         int numSegments = input.read();\n61         IOUtils.skipFully(input, numSegments);\n62     }\n63 \n64     private void readUserComment() throws VorbisCommentReaderException {\n65         try {\n66             long vectorLength = EndianUtils.readSwappedUnsignedInteger(input);\n67             if (vectorLength > 20 * 1024 * 1024) {\n68                 String keyPart = readUtf8String(10);\n69                 throw new VorbisCommentReaderException(\"User comment unrealistically long. \"\n70                         + \"key=\" + keyPart + \", length=\" + vectorLength);\n71             }\n72             String key = readContentVectorKey(vectorLength).toLowerCase(Locale.US);\n73             boolean shouldReadValue = handles(key);\n74             Log.d(TAG, \"key=\" + key + \", length=\" + vectorLength + \", handles=\" + shouldReadValue);\n75             if (shouldReadValue) {\n76                 String value = readUtf8String(vectorLength - key.length() - 1);\n77                 onContentVectorValue(key, value);\n78             } else {\n79                 IOUtils.skipFully(input, vectorLength - key.length() - 1);\n80             }\n81         } catch (IOException e) {\n82             e.printStackTrace();\n83         }\n84     }\n85 \n86     private String readUtf8String(long length) throws IOException {\n87         byte[] buffer = new byte[(int) length];\n88         IOUtils.readFully(input, buffer);\n89         Charset charset = Charset.forName(\"UTF-8\");\n90         return charset.newDecoder().decode(ByteBuffer.wrap(buffer)).toString();\n91     }\n92 \n93     /**\n94      * Looks for an identification header in the first page of the file. If an\n95      * identification header is found, it will be skipped completely\n96      */\n97     private void findIdentificationHeader() throws IOException {\n98         byte[] buffer = new byte[FIRST_OPUS_PAGE_LENGTH];\n99         IOUtils.readFully(input, buffer);\n100         final byte[] oggIdentificationHeader = new byte[]{ PACKET_TYPE_IDENTIFICATION, 'v', 'o', 'r', 'b', 'i', 's' };\n101         for (int i = 6; i < buffer.length; i++) {\n102             if (bufferMatches(buffer, oggIdentificationHeader, i)) {\n103                 IOUtils.skip(input, FIRST_OGG_PAGE_LENGTH - FIRST_OPUS_PAGE_LENGTH);\n104                 return;\n105             } else if (bufferMatches(buffer, \"OpusHead\".getBytes(), i)) {\n106                 return;\n107             }\n108         }\n109         throw new IOException(\"No vorbis identification header found\");\n110     }\n111 \n112     private void findCommentHeader() throws IOException {\n113         byte[] buffer = new byte[64]; // Enough space for some bytes. Used circularly.\n114         final byte[] oggCommentHeader = new byte[]{ PACKET_TYPE_COMMENT, 'v', 'o', 'r', 'b', 'i', 's' };\n115         for (int bytesRead = 0; bytesRead < SECOND_PAGE_MAX_LENGTH; bytesRead++) {\n116             buffer[bytesRead % buffer.length] = (byte) input.read();\n117             if (bufferMatches(buffer, oggCommentHeader, bytesRead)) {\n118                 return;\n119             } else if (bufferMatches(buffer, \"OpusTags\".getBytes(), bytesRead)) {\n120                 return;\n121             }\n122         }\n123         throw new IOException(\"No comment header found\");\n124     }\n125 \n126     /**\n127      * Reads backwards in haystack, starting at position. Checks if the bytes match needle.\n128      * Uses haystack circularly, so when reading at (-1), it reads at (length - 1).\n129      */\n130     boolean bufferMatches(byte[] haystack, byte[] needle, int position) {\n131         for (int i = 0; i < needle.length; i++) {\n132             int posInHaystack = position - i;\n133             while (posInHaystack < 0) {\n134                 posInHaystack += haystack.length;\n135             }\n136             posInHaystack = posInHaystack % haystack.length;\n137             if (haystack[posInHaystack] != needle[needle.length - 1 - i]) {\n138                 return false;\n139             }\n140         }\n141         return true;\n142     }\n143 \n144     @NonNull\n145     private VorbisCommentHeader readCommentHeader() throws IOException, VorbisCommentReaderException {\n146         try {\n147             long vendorLength = EndianUtils.readSwappedUnsignedInteger(input);\n148             String vendorName = readUtf8String(vendorLength);\n149             long userCommentLength = EndianUtils.readSwappedUnsignedInteger(input);\n150             return new VorbisCommentHeader(vendorName, userCommentLength);\n151         } catch (UnsupportedEncodingException e) {\n152             throw new VorbisCommentReaderException(e);\n153         }\n154     }\n155 \n156     private String readContentVectorKey(long vectorLength) throws IOException {\n157         StringBuilder builder = new StringBuilder();\n158         for (int i = 0; i < vectorLength; i++) {\n159             char c = (char) input.read();\n160             if (c == '=') {\n161                 return builder.toString();\n162             } else {\n163                 builder.append(c);\n164             }\n165         }\n166         return null; // no key found\n167     }\n168 \n169     /**\n170      * Is called every time the Reader finds a content vector. The handler\n171      * should return true if it wants to handle the content vector.\n172      */\n173     protected abstract boolean handles(String key);\n174 \n175     /**\n176      * Is called if onContentVectorKey returned true for the key.\n177      */\n178     protected abstract void onContentVectorValue(String key, String value) throws VorbisCommentReaderException;\n179 }\n180 \n[end of parser/media/src/main/java/de/danoeh/antennapod/parser/media/vorbis/VorbisCommentReader.java]\n</code>\n\nHere is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\nI need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the format shown above.\nRespond below:"}
{"instance_id": "AntennaPod__AntennaPod-7159", "model_name": "Gemini 2.5 Flash", "model_name_or_path": "google/gemini-2.5-flash", "generated_patch": "--- a/ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java\n+++ b/ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java\n@@ -15,6 +15,7 @@\n import de.danoeh.antennapod.parser.media.id3.ChapterReader;\n import de.danoeh.antennapod.parser.media.id3.ID3ReaderException;\n import de.danoeh.antennapod.model.playback.Playable;\n+import de.danoeh.antennapod.parser.media.mp4.Mp4ChapterReader;\n import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentChapterReader;\n import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentReaderException;\n import okhttp3.CacheControl;\n@@ -98,6 +99,19 @@\n         } catch (IOException | VorbisCommentReaderException e) {\n             Log.e(TAG, \"Unable to load vorbis chapters: \" + e.getMessage());\n         }\n+\n+        try (CountingInputStream in = openStream(playable, context)) {\n+            List<Chapter> chapters = readMp4ChaptersFromInputStream(in);\n+            if (!chapters.isEmpty()) {\n+                Log.i(TAG, \"Chapters loaded\");\n+                return chapters;\n+            }\n+        } catch (InterruptedIOException e) {\n+            throw e;\n+        } catch (IOException e) {\n+            Log.e(TAG, \"Unable to load MP4 chapters: \" + e.getMessage());\n+        }\n+\n         return null;\n     }\n \n@@ -167,6 +181,21 @@\n         return chapters;\n     }\n \n+    @NonNull\n+    private static List<Chapter> readMp4ChaptersFromInputStream(InputStream input) throws IOException {\n+        Mp4ChapterReader reader = new Mp4ChapterReader(input);\n+        reader.readInputStream();\n+        List<Chapter> chapters = reader.getChapters();\n+        if (chapters == null) {\n+            return Collections.emptyList();\n+        }\n+        Collections.sort(chapters, new ChapterStartTimeComparator());\n+        enumerateEmptyChapterTitles(chapters);\n+        if (chaptersValid(chapters)) {\n+            return chapters;\n+        }\n+        return Collections.emptyList();\n+    }\n     @NonNull\n     private static List<Chapter> readOggChaptersFromInputStream(InputStream input) throws VorbisCommentReaderException {\n         VorbisCommentChapterReader reader = new VorbisCommentChapterReader(new BufferedInputStream(input));", "full_output": "```diff\n--- a/ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java\n+++ b/ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java\n@@ -15,6 +15,7 @@\n import de.danoeh.antennapod.parser.media.id3.ChapterReader;\n import de.danoeh.antennapod.parser.media.id3.ID3ReaderException;\n import de.danoeh.antennapod.model.playback.Playable;\n+import de.danoeh.antennapod.parser.media.mp4.Mp4ChapterReader;\n import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentChapterReader;\n import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentReaderException;\n import okhttp3.CacheControl;\n@@ -98,6 +99,19 @@\n         } catch (IOException | VorbisCommentReaderException e) {\n             Log.e(TAG, \"Unable to load vorbis chapters: \" + e.getMessage());\n         }\n+\n+        try (CountingInputStream in = openStream(playable, context)) {\n+            List<Chapter> chapters = readMp4ChaptersFromInputStream(in);\n+            if (!chapters.isEmpty()) {\n+                Log.i(TAG, \"Chapters loaded\");\n+                return chapters;\n+            }\n+        } catch (InterruptedIOException e) {\n+            throw e;\n+        } catch (IOException e) {\n+            Log.e(TAG, \"Unable to load MP4 chapters: \" + e.getMessage());\n+        }\n+\n         return null;\n     }\n \n@@ -167,6 +181,21 @@\n         return chapters;\n     }\n \n+    @NonNull\n+    private static List<Chapter> readMp4ChaptersFromInputStream(InputStream input) throws IOException {\n+        Mp4ChapterReader reader = new Mp4ChapterReader(input);\n+        reader.readInputStream();\n+        List<Chapter> chapters = reader.getChapters();\n+        if (chapters == null) {\n+            return Collections.emptyList();\n+        }\n+        Collections.sort(chapters, new ChapterStartTimeComparator());\n+        enumerateEmptyChapterTitles(chapters);\n+        if (chaptersValid(chapters)) {\n+            return chapters;\n+        }\n+        return Collections.emptyList();\n+    }\n     @NonNull\n     private static List<Chapter> readOggChaptersFromInputStream(InputStream input) throws VorbisCommentReaderException {\n         VorbisCommentChapterReader reader = new VorbisCommentChapterReader(new BufferedInputStream(input));\n```", "prompt_tokens": 6161, "completion_tokens": 634, "total_tokens": 6795, "response_time": 0.9128508567810059, "cost": 0.0034333000000000002, "base_commit": "292a21f8f8a9aa1b389f27942730782ef451b6fa", "error": null, "timestamp": "2025-07-07T18:31:26.956867", "prompt": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nSupport for parsing m4a chapters\n# Checklist\r\n<!-- Place an x in the boxes to tick them: [x] -->\r\n\r\n- [x ] I have used the search function to see if someone else has already submitted the same bug report.\r\n- [x ] I will describe the problem with as much detail as possible.\r\n- [x ] If the bug only to occurs with a certain podcast, I will include the URL of that podcast.\r\n\r\n# System info\r\n<!-- The following information is very important to fill out because some bugs may only occur on certain devices or versions of Android. -->\r\n[ Environment ]\r\nAndroid version: 9\r\nOS version: 3.10.61-TeamNexus-flx-00210-g4cebbfb8cc42-dirty\r\nAntennaPod version: 1.8.1\r\nModel: SM-G920F\r\nDevice: zeroflte\r\nProduct: zerofltexx\r\nNo crash report recorded\r\n\r\n**App version**\r\n<!-- The latest version may be different depending on your device. You can find the version in AntennaPod's settings. -->\r\nAntennaPod 1.8.1 (6e6a64f50) ( tried versions from F-Droid and GooglePlayStore )\r\n\r\n**Android version**:\r\n9 ( Lineage OS 16.0 )\r\n\r\n**Device model**:\r\nSM-G920F\r\n\r\n# Bug description\r\nApp is unable to detect chapters/bookmarks in some podcast files (M4A) when chapter data is encoded at the end of audio file. \r\nThe app looks for chapter data in the beginning of the file, therefore is unable to detect chapters if \"chapter data\" is encoded at the end of the M4A. I have noted this issue with a few \"Apple Podcast M4A\" files, new apple non standard file shenanigans?\r\n\r\n**Steps to reproduce**:\r\nReplicate using this file http://audiocdn.economist.com/sites/default/files/AudioArchive/2020/20200725/Issue_9204_20200725_The_Economist_03_Leaders.m4a\r\nrun ffprobe to confirm that the file does contain chapter markers ffprobe -i Issue_9204_20200725_The_Economist_03_Leaders.m4a -show_chapters -loglevel error\r\n\r\nThis is how the Podcastaddict dev described the issue and fixed it, (devs feedback follows).**[...]** _The issue is that this specific podcast decided to move the chapter information at the end of the file instead of having them at the beginning which doesn't make any sense as it means that the app needs to get the whole file in order to just extract the metadata information. This podcast being especially long this would take a very long time and use a lot of data when streaming. I updated the app to be able to get those informations after the file gets downloaded as a workaround._ **[...]**\r\n\r\n**Expected behaviour**:\r\n<!-- After following the steps, what did you think AntennaPod would do? -->\r\nChapters/bookmarks in audio file should be detected and should be displayed\r\n\r\n**Current behaviour**:\r\n<!-- What did AntennaPod do instead? Screenshots might help. Usually, you can take a screenshot of your smartphone by pressing *Power* + *Volume down* for a few seconds. -->\r\nIs unable to detect chapters/bookmarks in some podcast files when \r\n**First occurred**: \r\nNew Install. Since install ( user migrated over from PodcastAddict ). \r\n**Environment**: \r\nNew install, default settings used.\r\n**Stacktrace/Logcat**:\r\n<!-- If you are experiencing a crash, including the stacktrace will likely get it fixed sooner. AntennaPod has an `export logs` feature for this. --> Not applicable, app did not crash\r\n```\r\n\r\n```\r\n\n\n</issue>\n\n<code>\n[start of README.md]\n1 # AntennaPod\n2 \n3 This is the official repository of AntennaPod, the easy-to-use, flexible and open-source podcast manager for Android.\n4 \n5 [<img src=\"https://play.google.com/intl/en_us/badges/images/generic/en_badge_web_generic.png\"\n6       alt=\"Get it on Google Play\"\n7       height=\"70\">](https://play.google.com/store/apps/details?id=de.danoeh.antennapod)\n8 [<img src=\"https://fdroid.gitlab.io/artwork/badge/get-it-on.png\"\n9       alt=\"Get it on F-Droid\"\n10       height=\"70\">](https://f-droid.org/app/de.danoeh.antennapod)\n11 \n12 <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/00.png\" alt=\"Screenshot 0\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/01.png\" alt=\"Screenshot 1\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/02.png\" alt=\"Screenshot 2\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/03.png\" alt=\"Screenshot 3\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/04.png\" alt=\"Screenshot 4\" height=\"200\"> <img src=\"https://raw.githubusercontent.com/AntennaPod/StoreMetadata/main/listings/en-US/graphics/phone-screenshots/05.png\" alt=\"Screenshot 5\" height=\"200\">\n13 \n14 \n15 ## Feedback\n16 You can use the [AntennaPod Forum](https://forum.antennapod.org/) for discussions about the app or just podcasting in general.\n17 \n18 Bug reports and feature requests can be submitted [here](https://github.com/AntennaPod/AntennaPod/issues) (please read the [instructions](https://github.com/AntennaPod/AntennaPod/blob/develop/CONTRIBUTING.md) on how to report a bug and how to submit a feature request first!).\n19 \n20 We also hold regular community calls to discuss anything AntennaPod-related. [Come join the next call](https://forum.antennapod.org/t/monthly-community-call/1869)!\n21 \n22 ## Help to test AntennaPod\n23 AntennaPod has many users and we don't want them to run into trouble when we add a new feature. It's important that we have a significant group test our app, so that we know all possible combinations of phones, Android versions and use cases work as expected. Check out our wiki on how to join our [Beta testing program](https://antennapod.org/documentation/general/beta)! If a bug is reported during the beta period, chances are high that it will be fixed before the stable version. If it is reported later, fixing might take another full beta cycle. So definitely let us know if something is not right.\n24 \n25 ## License\n26 \n27 AntennaPod is licensed under the GNU General Public License (GPL-3.0). You can find the license text in the LICENSE file.\n28 \n29 ## Translating AntennaPod\n30 \n31 If you want to translate AntennaPod into another language, you can visit the [Transifex project page](https://www.transifex.com/antennapod/antennapod/).\n32 \n33 \n34 ## Building AntennaPod\n35 \n36 You can build AntennaPod just like any other Android project. Refer to the [instructions](https://github.com/AntennaPod/AntennaPod/blob/develop/CONTRIBUTING.md) for more details.\n37 \n38 \n[end of README.md]\n[start of /dev/null]\n1 \n[end of /dev/null]\n[start of model/src/main/java/de/danoeh/antennapod/model/feed/Chapter.java]\n1 package de.danoeh.antennapod.model.feed;\n2 \n3 import java.util.List;\n4 \n5 public class Chapter {\n6     private long id;\n7     /** Defines starting point in milliseconds. */\n8     private long start;\n9     private String title;\n10     private String link;\n11     private String imageUrl;\n12     private String chapterId;\n13 \n14     public Chapter() {\n15     }\n16 \n17     public Chapter(long start, String title, String link, String imageUrl) {\n18         this.start = start;\n19         this.title = title;\n20         this.link = link;\n21         this.imageUrl = imageUrl;\n22     }\n23 \n24     public long getStart() {\n25         return start;\n26     }\n27 \n28     public String getTitle() {\n29         return title;\n30     }\n31 \n32     public String getLink() {\n33         return link;\n34     }\n35 \n36     public void setStart(long start) {\n37         this.start = start;\n38     }\n39 \n40     public void setTitle(String title) {\n41         this.title = title;\n42     }\n43 \n44     public void setLink(String link) {\n45         this.link = link;\n46     }\n47 \n48     public String getImageUrl() {\n49         return imageUrl;\n50     }\n51 \n52     public void setImageUrl(String imageUrl) {\n53         this.imageUrl = imageUrl;\n54     }\n55 \n56     /**\n57      * ID from the chapter source, not the database ID.\n58      */\n59     public String getChapterId() {\n60         return chapterId;\n61     }\n62 \n63     public void setChapterId(String chapterId) {\n64         this.chapterId = chapterId;\n65     }\n66 \n67     @Override\n68     public String toString() {\n69         return \"ID3Chapter [title=\" + getTitle() + \", start=\" + getStart() + \", url=\" + getLink() + \"]\";\n70     }\n71 \n72     public long getId() {\n73         return id;\n74     }\n75 \n76     public void setId(long id) {\n77         this.id = id;\n78     }\n79 \n80     public static int getAfterPosition(List<Chapter> chapters, int playbackPosition) {\n81         if (chapters == null || chapters.isEmpty()) {\n82             return -1;\n83         }\n84         for (int i = 0; i < chapters.size(); i++) {\n85             if (chapters.get(i).getStart() > playbackPosition) {\n86                 return i - 1;\n87             }\n88         }\n89         return chapters.size() - 1;\n90     }\n91 }\n92 \n[end of model/src/main/java/de/danoeh/antennapod/model/feed/Chapter.java]\n[start of ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java]\n1 package de.danoeh.antennapod.ui.chapters;\n2 \n3 import android.content.ContentResolver;\n4 import android.content.Context;\n5 import android.net.Uri;\n6 import android.text.TextUtils;\n7 import android.util.Log;\n8 import androidx.annotation.NonNull;\n9 import de.danoeh.antennapod.model.feed.Chapter;\n10 import de.danoeh.antennapod.model.feed.FeedMedia;\n11 import de.danoeh.antennapod.net.common.AntennapodHttpClient;\n12 import de.danoeh.antennapod.storage.database.DBReader;\n13 import de.danoeh.antennapod.parser.feed.PodcastIndexChapterParser;\n14 import de.danoeh.antennapod.parser.media.id3.ChapterReader;\n15 import de.danoeh.antennapod.parser.media.id3.ID3ReaderException;\n16 import de.danoeh.antennapod.model.playback.Playable;\n17 import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentChapterReader;\n18 import de.danoeh.antennapod.parser.media.vorbis.VorbisCommentReaderException;\n19 import okhttp3.CacheControl;\n20 import okhttp3.Request;\n21 import okhttp3.Response;\n22 import org.apache.commons.io.input.CountingInputStream;\n23 \n24 import java.io.BufferedInputStream;\n25 import java.io.File;\n26 import java.io.FileInputStream;\n27 import java.io.IOException;\n28 import java.io.InputStream;\n29 import java.io.InterruptedIOException;\n30 import java.util.Collections;\n31 import java.util.Comparator;\n32 import java.util.List;\n33 \n34 /**\n35  * Utility class for getting chapter data from media files.\n36  */\n37 public class ChapterUtils {\n38 \n39     private static final String TAG = \"ChapterUtils\";\n40 \n41     private ChapterUtils() {\n42     }\n43 \n44     public static void loadChapters(Playable playable, Context context, boolean forceRefresh) {\n45         if (playable.getChapters() != null && !forceRefresh) {\n46             // Already loaded\n47             return;\n48         }\n49 \n50         try {\n51             List<Chapter> chaptersFromDatabase = null;\n52             List<Chapter> chaptersFromPodcastIndex = null;\n53             if (playable instanceof FeedMedia) {\n54                 FeedMedia feedMedia = (FeedMedia) playable;\n55                 if (feedMedia.getItem() == null) {\n56                     feedMedia.setItem(DBReader.getFeedItem(feedMedia.getItemId()));\n57                 }\n58                 if (feedMedia.getItem().hasChapters()) {\n59                     chaptersFromDatabase = DBReader.loadChaptersOfFeedItem(feedMedia.getItem());\n60                 }\n61 \n62                 if (!TextUtils.isEmpty(feedMedia.getItem().getPodcastIndexChapterUrl())) {\n63                     chaptersFromPodcastIndex = ChapterUtils.loadChaptersFromUrl(\n64                             feedMedia.getItem().getPodcastIndexChapterUrl(), forceRefresh);\n65                 }\n66 \n67             }\n68 \n69             List<Chapter> chaptersFromMediaFile = ChapterUtils.loadChaptersFromMediaFile(playable, context);\n70             List<Chapter> chaptersMergePhase1 = ChapterMerger.merge(chaptersFromDatabase, chaptersFromMediaFile);\n71             List<Chapter> chapters = ChapterMerger.merge(chaptersMergePhase1, chaptersFromPodcastIndex);\n72             if (chapters == null) {\n73                 // Do not try loading again. There are no chapters or parsing failed.\n74                 playable.setChapters(Collections.emptyList());\n75             } else {\n76                 playable.setChapters(chapters);\n77             }\n78         } catch (InterruptedIOException e) {\n79             Log.d(TAG, \"Chapter loading interrupted\");\n80             playable.setChapters(null); // Allow later retry\n81         }\n82     }\n83 \n84     public static List<Chapter> loadChaptersFromMediaFile(Playable playable, Context context)\n85             throws InterruptedIOException {\n86         try (CountingInputStream in = openStream(playable, context)) {\n87             List<Chapter> chapters = readId3ChaptersFrom(in);\n88             if (!chapters.isEmpty()) {\n89                 Log.i(TAG, \"Chapters loaded\");\n90                 return chapters;\n91             }\n92         } catch (InterruptedIOException e) {\n93             throw e;\n94         } catch (IOException | ID3ReaderException e) {\n95             Log.e(TAG, \"Unable to load ID3 chapters: \" + e.getMessage());\n96         }\n97 \n98         try (CountingInputStream in = openStream(playable, context)) {\n99             List<Chapter> chapters = readOggChaptersFromInputStream(in);\n100             if (!chapters.isEmpty()) {\n101                 Log.i(TAG, \"Chapters loaded\");\n102                 return chapters;\n103             }\n104         } catch (InterruptedIOException e) {\n105             throw e;\n106         } catch (IOException | VorbisCommentReaderException e) {\n107             Log.e(TAG, \"Unable to load vorbis chapters: \" + e.getMessage());\n108         }\n109         return null;\n110     }\n111 \n112     private static CountingInputStream openStream(Playable playable, Context context) throws IOException {\n113         if (playable.localFileAvailable()) {\n114             if (playable.getLocalFileUrl() == null) {\n115                 throw new IOException(\"No local url\");\n116             }\n117             File source = new File(playable.getLocalFileUrl());\n118             if (!source.exists()) {\n119                 throw new IOException(\"Local file does not exist\");\n120             }\n121             return new CountingInputStream(new BufferedInputStream(new FileInputStream(source)));\n122         } else if (playable.getStreamUrl().startsWith(ContentResolver.SCHEME_CONTENT)) {\n123             Uri uri = Uri.parse(playable.getStreamUrl());\n124             return new CountingInputStream(new BufferedInputStream(context.getContentResolver().openInputStream(uri)));\n125         } else {\n126             Request request = new Request.Builder().url(playable.getStreamUrl()).build();\n127             Response response = AntennapodHttpClient.getHttpClient().newCall(request).execute();\n128             if (response.body() == null) {\n129                 throw new IOException(\"Body is null\");\n130             }\n131             return new CountingInputStream(new BufferedInputStream(response.body().byteStream()));\n132         }\n133     }\n134 \n135     public static List<Chapter> loadChaptersFromUrl(String url, boolean forceRefresh) throws InterruptedIOException {\n136         if (forceRefresh) {\n137             return loadChaptersFromUrl(url, CacheControl.FORCE_NETWORK);\n138         }\n139         List<Chapter> cachedChapters = loadChaptersFromUrl(url, CacheControl.FORCE_CACHE);\n140         if (cachedChapters == null || cachedChapters.size() <= 1) {\n141             // Some publishers use one dummy chapter before actual chapters are available\n142             return loadChaptersFromUrl(url, CacheControl.FORCE_NETWORK);\n143         }\n144         return cachedChapters;\n145     }\n146 \n147     private static List<Chapter> loadChaptersFromUrl(String url, CacheControl cacheControl)\n148             throws InterruptedIOException {\n149         Response response = null;\n150         try {\n151             Request request = new Request.Builder().url(url).cacheControl(cacheControl).build();\n152             response = AntennapodHttpClient.getHttpClient().newCall(request).execute();\n153             if (response.isSuccessful() && response.body() != null) {\n154                 return PodcastIndexChapterParser.parse(response.body().string());\n155             }\n156         } catch (InterruptedIOException e) {\n157             throw e;\n158         } catch (IOException e) {\n159             e.printStackTrace();\n160         } finally {\n161             if (response != null) {\n162                 response.close();\n163             }\n164         }\n165         return null;\n166     }\n167 \n168     @NonNull\n169     private static List<Chapter> readId3ChaptersFrom(CountingInputStream in) throws IOException, ID3ReaderException {\n170         ChapterReader reader = new ChapterReader(in);\n171         reader.readInputStream();\n172         List<Chapter> chapters = reader.getChapters();\n173         Collections.sort(chapters, new ChapterStartTimeComparator());\n174         enumerateEmptyChapterTitles(chapters);\n175         if (!chaptersValid(chapters)) {\n176             Log.e(TAG, \"Chapter data was invalid\");\n177             return Collections.emptyList();\n178         }\n179         return chapters;\n180     }\n181 \n182     @NonNull\n183     private static List<Chapter> readOggChaptersFromInputStream(InputStream input) throws VorbisCommentReaderException {\n184         VorbisCommentChapterReader reader = new VorbisCommentChapterReader(new BufferedInputStream(input));\n185         reader.readInputStream();\n186         List<Chapter> chapters = reader.getChapters();\n187         if (chapters == null) {\n188             return Collections.emptyList();\n189         }\n190         Collections.sort(chapters, new ChapterStartTimeComparator());\n191         enumerateEmptyChapterTitles(chapters);\n192         if (chaptersValid(chapters)) {\n193             return chapters;\n194         }\n195         return Collections.emptyList();\n196     }\n197 \n198     /**\n199      * Makes sure that chapter does a title and an item attribute.\n200      */\n201     private static void enumerateEmptyChapterTitles(List<Chapter> chapters) {\n202         for (int i = 0; i < chapters.size(); i++) {\n203             Chapter c = chapters.get(i);\n204             if (c.getTitle() == null) {\n205                 c.setTitle(Integer.toString(i));\n206             }\n207         }\n208     }\n209 \n210     private static boolean chaptersValid(List<Chapter> chapters) {\n211         if (chapters.isEmpty()) {\n212             return false;\n213         }\n214         for (Chapter c : chapters) {\n215             if (c.getStart() < 0) {\n216                 return false;\n217             }\n218         }\n219         return true;\n220     }\n221 \n222     public static class ChapterStartTimeComparator implements Comparator<Chapter> {\n223         @Override\n224         public int compare(Chapter lhs, Chapter rhs) {\n225             return Long.compare(lhs.getStart(), rhs.getStart());\n226         }\n227     }\n228 }\n229 \n[end of ui/chapters/src/main/java/de/danoeh/antennapod/ui/chapters/ChapterUtils.java]\n</code>\n\nHere is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\nI need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the format shown above.\nRespond below:"}
